/* 
 * Reepay API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace ReepayApi.Model
{
    /// <summary>
    /// SupersedeSubscriptionPlan
    /// </summary>
    [DataContract]
    public partial class SupersedeSubscriptionPlan :  IEquatable<SupersedeSubscriptionPlan>
    {
        /// <summary>
        /// How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.
        /// </summary>
        /// <value>How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum PartialPeriodHandlingEnum
        {
            
            /// <summary>
            /// Enum Billfull for "bill_full"
            /// </summary>
            [EnumMember(Value = "bill_full")]
            Billfull,
            
            /// <summary>
            /// Enum Billprorated for "bill_prorated"
            /// </summary>
            [EnumMember(Value = "bill_prorated")]
            Billprorated,
            
            /// <summary>
            /// Enum Billzeroamount for "bill_zero_amount"
            /// </summary>
            [EnumMember(Value = "bill_zero_amount")]
            Billzeroamount,
            
            /// <summary>
            /// Enum Nobill for "no_bill"
            /// </summary>
            [EnumMember(Value = "no_bill")]
            Nobill
        }

        /// <summary>
        /// Time unit use for fixed life time
        /// </summary>
        /// <value>Time unit use for fixed life time</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum FixedLifeTimeUnitEnum
        {
            
            /// <summary>
            /// Enum Months for "months"
            /// </summary>
            [EnumMember(Value = "months")]
            Months,
            
            /// <summary>
            /// Enum Days for "days"
            /// </summary>
            [EnumMember(Value = "days")]
            Days
        }

        /// <summary>
        /// Time unit for free trial period
        /// </summary>
        /// <value>Time unit for free trial period</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TrialIntervalUnitEnum
        {
            
            /// <summary>
            /// Enum Months for "months"
            /// </summary>
            [EnumMember(Value = "months")]
            Months,
            
            /// <summary>
            /// Enum Days for "days"
            /// </summary>
            [EnumMember(Value = "days")]
            Days
        }

        /// <summary>
        /// Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.
        /// </summary>
        /// <value>Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ScheduleTypeEnum
        {
            
            /// <summary>
            /// Enum Manual for "manual"
            /// </summary>
            [EnumMember(Value = "manual")]
            Manual,
            
            /// <summary>
            /// Enum Daily for "daily"
            /// </summary>
            [EnumMember(Value = "daily")]
            Daily,
            
            /// <summary>
            /// Enum Weeklyfixedday for "weekly_fixedday"
            /// </summary>
            [EnumMember(Value = "weekly_fixedday")]
            Weeklyfixedday,
            
            /// <summary>
            /// Enum Monthstartdate for "month_startdate"
            /// </summary>
            [EnumMember(Value = "month_startdate")]
            Monthstartdate,
            
            /// <summary>
            /// Enum Monthfixedday for "month_fixedday"
            /// </summary>
            [EnumMember(Value = "month_fixedday")]
            Monthfixedday,
            
            /// <summary>
            /// Enum Monthlastday for "month_lastday"
            /// </summary>
            [EnumMember(Value = "month_lastday")]
            Monthlastday
        }

        /// <summary>
        /// Action to take after a subscription plan is superseded, one of the following: `no_sub_update`, `scheduled_sub_update`, `instant_sub_update`. Default is `no_sub_update`.
        /// </summary>
        /// <value>Action to take after a subscription plan is superseded, one of the following: `no_sub_update`, `scheduled_sub_update`, `instant_sub_update`. Default is `no_sub_update`.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum SupersedeModeEnum
        {
            
            /// <summary>
            /// Enum Nosubupdate for "no_sub_update"
            /// </summary>
            [EnumMember(Value = "no_sub_update")]
            Nosubupdate,
            
            /// <summary>
            /// Enum Scheduledsubupdate for "scheduled_sub_update"
            /// </summary>
            [EnumMember(Value = "scheduled_sub_update")]
            Scheduledsubupdate,
            
            /// <summary>
            /// Enum Instantsubupdate for "instant_sub_update"
            /// </summary>
            [EnumMember(Value = "instant_sub_update")]
            Instantsubupdate
        }

        /// <summary>
        /// How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.
        /// </summary>
        /// <value>How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.</value>
        [DataMember(Name="partial_period_handling", EmitDefaultValue=false)]
        public PartialPeriodHandlingEnum? PartialPeriodHandling { get; set; }
        /// <summary>
        /// Time unit use for fixed life time
        /// </summary>
        /// <value>Time unit use for fixed life time</value>
        [DataMember(Name="fixed_life_time_unit", EmitDefaultValue=false)]
        public FixedLifeTimeUnitEnum? FixedLifeTimeUnit { get; set; }
        /// <summary>
        /// Time unit for free trial period
        /// </summary>
        /// <value>Time unit for free trial period</value>
        [DataMember(Name="trial_interval_unit", EmitDefaultValue=false)]
        public TrialIntervalUnitEnum? TrialIntervalUnit { get; set; }
        /// <summary>
        /// Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.
        /// </summary>
        /// <value>Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.</value>
        [DataMember(Name="schedule_type", EmitDefaultValue=false)]
        public ScheduleTypeEnum? ScheduleType { get; set; }
        /// <summary>
        /// Action to take after a subscription plan is superseded, one of the following: `no_sub_update`, `scheduled_sub_update`, `instant_sub_update`. Default is `no_sub_update`.
        /// </summary>
        /// <value>Action to take after a subscription plan is superseded, one of the following: `no_sub_update`, `scheduled_sub_update`, `instant_sub_update`. Default is `no_sub_update`.</value>
        [DataMember(Name="supersede_mode", EmitDefaultValue=false)]
        public SupersedeModeEnum? SupersedeMode { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="SupersedeSubscriptionPlan" /> class.
        /// </summary>
        [JsonConstructor]
        protected SupersedeSubscriptionPlan() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SupersedeSubscriptionPlan" /> class.
        /// </summary>
        /// <param name="Name">Name of the plan (required).</param>
        /// <param name="Description">Description of the plan.</param>
        /// <param name="Vat">Optional vat for this plan. Account default is used if none given..</param>
        /// <param name="Quantity">Optional default quantity of the subscription plan product for new subscriptions. Default is 1..</param>
        /// <param name="Prepaid">Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios. (required) (default to false).</param>
        /// <param name="DunningPlan">Dunning plan handle.</param>
        /// <param name="RenewalReminderEmailDays">Optional renewal reminder email settings. Number of days before next billing to send a reminder email..</param>
        /// <param name="TrialReminderEmailDays">Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email..</param>
        /// <param name="PartialPeriodHandling">How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: &#x60;bill_full&#x60;, &#x60;bill_prorated&#x60;, &#x60;bill_zero_amount&#x60;, &#x60;no_bill&#x60;..</param>
        /// <param name="AmountInclVat">Whether the amount is including VAT. Default true. (default to false).</param>
        /// <param name="FixedCount">Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices..</param>
        /// <param name="FixedLifeTimeUnit">Time unit use for fixed life time.</param>
        /// <param name="FixedLifeTimeLength">Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends..</param>
        /// <param name="TrialIntervalUnit">Time unit for free trial period.</param>
        /// <param name="TrialIntervalLength">Free trial interval length. E.g. 1 month..</param>
        /// <param name="IntervalLength">The length of intervals. E.g. every second month or every 14 days. (required).</param>
        /// <param name="ScheduleType">Scheduling type, one of the following: &#x60;manual&#x60;, &#x60;daily&#x60;, &#x60;weekly_fixedday&#x60;, &#x60;month_startdate&#x60;, &#x60;month_fixedday&#x60;, &#x60;month_lastday&#x60;. See documentation for descriptions of the different types. (required).</param>
        /// <param name="ScheduleFixedDay">If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7.</param>
        /// <param name="BaseMonth">For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as &#x60;base_month + k * interval_length&#x60; up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, base_month 1 and inrerval_length 3 can be used. If not defined the first fixed day will be used as start of first billing period..</param>
        /// <param name="NoticePeriods">Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See &#x60;notice_periods_after_current&#x60;. The default is to expire at the end of current period..</param>
        /// <param name="NoticePeriodsAfterCurrent">If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. (default to false).</param>
        /// <param name="FixationPeriods">Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel..</param>
        /// <param name="FixationPeriodsFull">If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly &#x60;fixation_periods&#x60; paid periods. Default is false. (default to false).</param>
        /// <param name="SupersedeMode">Action to take after a subscription plan is superseded, one of the following: &#x60;no_sub_update&#x60;, &#x60;scheduled_sub_update&#x60;, &#x60;instant_sub_update&#x60;. Default is &#x60;no_sub_update&#x60;..</param>
        public SupersedeSubscriptionPlan(string Name = null, string Description = null, float? Vat = null, int? Quantity = null, bool? Prepaid = null, string DunningPlan = null, int? RenewalReminderEmailDays = null, int? TrialReminderEmailDays = null, PartialPeriodHandlingEnum? PartialPeriodHandling = null, bool? AmountInclVat = null, int? FixedCount = null, FixedLifeTimeUnitEnum? FixedLifeTimeUnit = null, int? FixedLifeTimeLength = null, TrialIntervalUnitEnum? TrialIntervalUnit = null, int? TrialIntervalLength = null, int? IntervalLength = null, ScheduleTypeEnum? ScheduleType = null, int? ScheduleFixedDay = null, int? BaseMonth = null, int? NoticePeriods = null, bool? NoticePeriodsAfterCurrent = null, int? FixationPeriods = null, bool? FixationPeriodsFull = null, SupersedeModeEnum? SupersedeMode = null)
        {
            // to ensure "Name" is required (not null)
            if (Name == null)
            {
                throw new InvalidDataException("Name is a required property for SupersedeSubscriptionPlan and cannot be null");
            }
            else
            {
                this.Name = Name;
            }
            // to ensure "Prepaid" is required (not null)
            if (Prepaid == null)
            {
                throw new InvalidDataException("Prepaid is a required property for SupersedeSubscriptionPlan and cannot be null");
            }
            else
            {
                this.Prepaid = Prepaid;
            }
            // to ensure "IntervalLength" is required (not null)
            if (IntervalLength == null)
            {
                throw new InvalidDataException("IntervalLength is a required property for SupersedeSubscriptionPlan and cannot be null");
            }
            else
            {
                this.IntervalLength = IntervalLength;
            }
            // to ensure "ScheduleType" is required (not null)
            if (ScheduleType == null)
            {
                throw new InvalidDataException("ScheduleType is a required property for SupersedeSubscriptionPlan and cannot be null");
            }
            else
            {
                this.ScheduleType = ScheduleType;
            }
            this.Description = Description;
            this.Vat = Vat;
            this.Quantity = Quantity;
            this.DunningPlan = DunningPlan;
            this.RenewalReminderEmailDays = RenewalReminderEmailDays;
            this.TrialReminderEmailDays = TrialReminderEmailDays;
            this.PartialPeriodHandling = PartialPeriodHandling;
            // use default value if no "AmountInclVat" provided
            if (AmountInclVat == null)
            {
                this.AmountInclVat = false;
            }
            else
            {
                this.AmountInclVat = AmountInclVat;
            }
            this.FixedCount = FixedCount;
            this.FixedLifeTimeUnit = FixedLifeTimeUnit;
            this.FixedLifeTimeLength = FixedLifeTimeLength;
            this.TrialIntervalUnit = TrialIntervalUnit;
            this.TrialIntervalLength = TrialIntervalLength;
            this.ScheduleFixedDay = ScheduleFixedDay;
            this.BaseMonth = BaseMonth;
            this.NoticePeriods = NoticePeriods;
            // use default value if no "NoticePeriodsAfterCurrent" provided
            if (NoticePeriodsAfterCurrent == null)
            {
                this.NoticePeriodsAfterCurrent = false;
            }
            else
            {
                this.NoticePeriodsAfterCurrent = NoticePeriodsAfterCurrent;
            }
            this.FixationPeriods = FixationPeriods;
            // use default value if no "FixationPeriodsFull" provided
            if (FixationPeriodsFull == null)
            {
                this.FixationPeriodsFull = false;
            }
            else
            {
                this.FixationPeriodsFull = FixationPeriodsFull;
            }
            this.SupersedeMode = SupersedeMode;
        }
        
        /// <summary>
        /// Name of the plan
        /// </summary>
        /// <value>Name of the plan</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }
        /// <summary>
        /// Description of the plan
        /// </summary>
        /// <value>Description of the plan</value>
        [DataMember(Name="description", EmitDefaultValue=false)]
        public string Description { get; set; }
        /// <summary>
        /// Optional vat for this plan. Account default is used if none given.
        /// </summary>
        /// <value>Optional vat for this plan. Account default is used if none given.</value>
        [DataMember(Name="vat", EmitDefaultValue=false)]
        public float? Vat { get; set; }
        /// <summary>
        /// Amount for the plan in the smallest unit for the account currency including VAT
        /// </summary>
        /// <value>Amount for the plan in the smallest unit for the account currency including VAT</value>
        [DataMember(Name="amount", EmitDefaultValue=false)]
        public int? Amount { get; private set; }
        /// <summary>
        /// Optional default quantity of the subscription plan product for new subscriptions. Default is 1.
        /// </summary>
        /// <value>Optional default quantity of the subscription plan product for new subscriptions. Default is 1.</value>
        [DataMember(Name="quantity", EmitDefaultValue=false)]
        public int? Quantity { get; set; }
        /// <summary>
        /// Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.
        /// </summary>
        /// <value>Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.</value>
        [DataMember(Name="prepaid", EmitDefaultValue=false)]
        public bool? Prepaid { get; set; }
        /// <summary>
        /// Dunning plan handle
        /// </summary>
        /// <value>Dunning plan handle</value>
        [DataMember(Name="dunning_plan", EmitDefaultValue=false)]
        public string DunningPlan { get; set; }
        /// <summary>
        /// Optional renewal reminder email settings. Number of days before next billing to send a reminder email.
        /// </summary>
        /// <value>Optional renewal reminder email settings. Number of days before next billing to send a reminder email.</value>
        [DataMember(Name="renewal_reminder_email_days", EmitDefaultValue=false)]
        public int? RenewalReminderEmailDays { get; set; }
        /// <summary>
        /// Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.
        /// </summary>
        /// <value>Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.</value>
        [DataMember(Name="trial_reminder_email_days", EmitDefaultValue=false)]
        public int? TrialReminderEmailDays { get; set; }
        /// <summary>
        /// Whether the amount is including VAT. Default true.
        /// </summary>
        /// <value>Whether the amount is including VAT. Default true.</value>
        [DataMember(Name="amount_incl_vat", EmitDefaultValue=false)]
        public bool? AmountInclVat { get; set; }
        /// <summary>
        /// Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices.
        /// </summary>
        /// <value>Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices.</value>
        [DataMember(Name="fixed_count", EmitDefaultValue=false)]
        public int? FixedCount { get; set; }
        /// <summary>
        /// Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.
        /// </summary>
        /// <value>Fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.</value>
        [DataMember(Name="fixed_life_time_length", EmitDefaultValue=false)]
        public int? FixedLifeTimeLength { get; set; }
        /// <summary>
        /// Free trial interval length. E.g. 1 month.
        /// </summary>
        /// <value>Free trial interval length. E.g. 1 month.</value>
        [DataMember(Name="trial_interval_length", EmitDefaultValue=false)]
        public int? TrialIntervalLength { get; set; }
        /// <summary>
        /// The length of intervals. E.g. every second month or every 14 days.
        /// </summary>
        /// <value>The length of intervals. E.g. every second month or every 14 days.</value>
        [DataMember(Name="interval_length", EmitDefaultValue=false)]
        public int? IntervalLength { get; set; }
        /// <summary>
        /// If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7
        /// </summary>
        /// <value>If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7</value>
        [DataMember(Name="schedule_fixed_day", EmitDefaultValue=false)]
        public int? ScheduleFixedDay { get; set; }
        /// <summary>
        /// For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as &#x60;base_month + k * interval_length&#x60; up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, base_month 1 and inrerval_length 3 can be used. If not defined the first fixed day will be used as start of first billing period.
        /// </summary>
        /// <value>For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as &#x60;base_month + k * interval_length&#x60; up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, base_month 1 and inrerval_length 3 can be used. If not defined the first fixed day will be used as start of first billing period.</value>
        [DataMember(Name="base_month", EmitDefaultValue=false)]
        public int? BaseMonth { get; set; }
        /// <summary>
        /// Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See &#x60;notice_periods_after_current&#x60;. The default is to expire at the end of current period.
        /// </summary>
        /// <value>Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See &#x60;notice_periods_after_current&#x60;. The default is to expire at the end of current period.</value>
        [DataMember(Name="notice_periods", EmitDefaultValue=false)]
        public int? NoticePeriods { get; set; }
        /// <summary>
        /// If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true.
        /// </summary>
        /// <value>If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true.</value>
        [DataMember(Name="notice_periods_after_current", EmitDefaultValue=false)]
        public bool? NoticePeriodsAfterCurrent { get; set; }
        /// <summary>
        /// Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel.
        /// </summary>
        /// <value>Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel.</value>
        [DataMember(Name="fixation_periods", EmitDefaultValue=false)]
        public int? FixationPeriods { get; set; }
        /// <summary>
        /// If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly &#x60;fixation_periods&#x60; paid periods. Default is false.
        /// </summary>
        /// <value>If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly &#x60;fixation_periods&#x60; paid periods. Default is false.</value>
        [DataMember(Name="fixation_periods_full", EmitDefaultValue=false)]
        public bool? FixationPeriodsFull { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SupersedeSubscriptionPlan {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Vat: ").Append(Vat).Append("\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  Quantity: ").Append(Quantity).Append("\n");
            sb.Append("  Prepaid: ").Append(Prepaid).Append("\n");
            sb.Append("  DunningPlan: ").Append(DunningPlan).Append("\n");
            sb.Append("  RenewalReminderEmailDays: ").Append(RenewalReminderEmailDays).Append("\n");
            sb.Append("  TrialReminderEmailDays: ").Append(TrialReminderEmailDays).Append("\n");
            sb.Append("  PartialPeriodHandling: ").Append(PartialPeriodHandling).Append("\n");
            sb.Append("  AmountInclVat: ").Append(AmountInclVat).Append("\n");
            sb.Append("  FixedCount: ").Append(FixedCount).Append("\n");
            sb.Append("  FixedLifeTimeUnit: ").Append(FixedLifeTimeUnit).Append("\n");
            sb.Append("  FixedLifeTimeLength: ").Append(FixedLifeTimeLength).Append("\n");
            sb.Append("  TrialIntervalUnit: ").Append(TrialIntervalUnit).Append("\n");
            sb.Append("  TrialIntervalLength: ").Append(TrialIntervalLength).Append("\n");
            sb.Append("  IntervalLength: ").Append(IntervalLength).Append("\n");
            sb.Append("  ScheduleType: ").Append(ScheduleType).Append("\n");
            sb.Append("  ScheduleFixedDay: ").Append(ScheduleFixedDay).Append("\n");
            sb.Append("  BaseMonth: ").Append(BaseMonth).Append("\n");
            sb.Append("  NoticePeriods: ").Append(NoticePeriods).Append("\n");
            sb.Append("  NoticePeriodsAfterCurrent: ").Append(NoticePeriodsAfterCurrent).Append("\n");
            sb.Append("  FixationPeriods: ").Append(FixationPeriods).Append("\n");
            sb.Append("  FixationPeriodsFull: ").Append(FixationPeriodsFull).Append("\n");
            sb.Append("  SupersedeMode: ").Append(SupersedeMode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as SupersedeSubscriptionPlan);
        }

        /// <summary>
        /// Returns true if SupersedeSubscriptionPlan instances are equal
        /// </summary>
        /// <param name="other">Instance of SupersedeSubscriptionPlan to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SupersedeSubscriptionPlan other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Name == other.Name ||
                    this.Name != null &&
                    this.Name.Equals(other.Name)
                ) && 
                (
                    this.Description == other.Description ||
                    this.Description != null &&
                    this.Description.Equals(other.Description)
                ) && 
                (
                    this.Vat == other.Vat ||
                    this.Vat != null &&
                    this.Vat.Equals(other.Vat)
                ) && 
                (
                    this.Amount == other.Amount ||
                    this.Amount != null &&
                    this.Amount.Equals(other.Amount)
                ) && 
                (
                    this.Quantity == other.Quantity ||
                    this.Quantity != null &&
                    this.Quantity.Equals(other.Quantity)
                ) && 
                (
                    this.Prepaid == other.Prepaid ||
                    this.Prepaid != null &&
                    this.Prepaid.Equals(other.Prepaid)
                ) && 
                (
                    this.DunningPlan == other.DunningPlan ||
                    this.DunningPlan != null &&
                    this.DunningPlan.Equals(other.DunningPlan)
                ) && 
                (
                    this.RenewalReminderEmailDays == other.RenewalReminderEmailDays ||
                    this.RenewalReminderEmailDays != null &&
                    this.RenewalReminderEmailDays.Equals(other.RenewalReminderEmailDays)
                ) && 
                (
                    this.TrialReminderEmailDays == other.TrialReminderEmailDays ||
                    this.TrialReminderEmailDays != null &&
                    this.TrialReminderEmailDays.Equals(other.TrialReminderEmailDays)
                ) && 
                (
                    this.PartialPeriodHandling == other.PartialPeriodHandling ||
                    this.PartialPeriodHandling != null &&
                    this.PartialPeriodHandling.Equals(other.PartialPeriodHandling)
                ) && 
                (
                    this.AmountInclVat == other.AmountInclVat ||
                    this.AmountInclVat != null &&
                    this.AmountInclVat.Equals(other.AmountInclVat)
                ) && 
                (
                    this.FixedCount == other.FixedCount ||
                    this.FixedCount != null &&
                    this.FixedCount.Equals(other.FixedCount)
                ) && 
                (
                    this.FixedLifeTimeUnit == other.FixedLifeTimeUnit ||
                    this.FixedLifeTimeUnit != null &&
                    this.FixedLifeTimeUnit.Equals(other.FixedLifeTimeUnit)
                ) && 
                (
                    this.FixedLifeTimeLength == other.FixedLifeTimeLength ||
                    this.FixedLifeTimeLength != null &&
                    this.FixedLifeTimeLength.Equals(other.FixedLifeTimeLength)
                ) && 
                (
                    this.TrialIntervalUnit == other.TrialIntervalUnit ||
                    this.TrialIntervalUnit != null &&
                    this.TrialIntervalUnit.Equals(other.TrialIntervalUnit)
                ) && 
                (
                    this.TrialIntervalLength == other.TrialIntervalLength ||
                    this.TrialIntervalLength != null &&
                    this.TrialIntervalLength.Equals(other.TrialIntervalLength)
                ) && 
                (
                    this.IntervalLength == other.IntervalLength ||
                    this.IntervalLength != null &&
                    this.IntervalLength.Equals(other.IntervalLength)
                ) && 
                (
                    this.ScheduleType == other.ScheduleType ||
                    this.ScheduleType != null &&
                    this.ScheduleType.Equals(other.ScheduleType)
                ) && 
                (
                    this.ScheduleFixedDay == other.ScheduleFixedDay ||
                    this.ScheduleFixedDay != null &&
                    this.ScheduleFixedDay.Equals(other.ScheduleFixedDay)
                ) && 
                (
                    this.BaseMonth == other.BaseMonth ||
                    this.BaseMonth != null &&
                    this.BaseMonth.Equals(other.BaseMonth)
                ) && 
                (
                    this.NoticePeriods == other.NoticePeriods ||
                    this.NoticePeriods != null &&
                    this.NoticePeriods.Equals(other.NoticePeriods)
                ) && 
                (
                    this.NoticePeriodsAfterCurrent == other.NoticePeriodsAfterCurrent ||
                    this.NoticePeriodsAfterCurrent != null &&
                    this.NoticePeriodsAfterCurrent.Equals(other.NoticePeriodsAfterCurrent)
                ) && 
                (
                    this.FixationPeriods == other.FixationPeriods ||
                    this.FixationPeriods != null &&
                    this.FixationPeriods.Equals(other.FixationPeriods)
                ) && 
                (
                    this.FixationPeriodsFull == other.FixationPeriodsFull ||
                    this.FixationPeriodsFull != null &&
                    this.FixationPeriodsFull.Equals(other.FixationPeriodsFull)
                ) && 
                (
                    this.SupersedeMode == other.SupersedeMode ||
                    this.SupersedeMode != null &&
                    this.SupersedeMode.Equals(other.SupersedeMode)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Name != null)
                    hash = hash * 59 + this.Name.GetHashCode();
                if (this.Description != null)
                    hash = hash * 59 + this.Description.GetHashCode();
                if (this.Vat != null)
                    hash = hash * 59 + this.Vat.GetHashCode();
                if (this.Amount != null)
                    hash = hash * 59 + this.Amount.GetHashCode();
                if (this.Quantity != null)
                    hash = hash * 59 + this.Quantity.GetHashCode();
                if (this.Prepaid != null)
                    hash = hash * 59 + this.Prepaid.GetHashCode();
                if (this.DunningPlan != null)
                    hash = hash * 59 + this.DunningPlan.GetHashCode();
                if (this.RenewalReminderEmailDays != null)
                    hash = hash * 59 + this.RenewalReminderEmailDays.GetHashCode();
                if (this.TrialReminderEmailDays != null)
                    hash = hash * 59 + this.TrialReminderEmailDays.GetHashCode();
                if (this.PartialPeriodHandling != null)
                    hash = hash * 59 + this.PartialPeriodHandling.GetHashCode();
                if (this.AmountInclVat != null)
                    hash = hash * 59 + this.AmountInclVat.GetHashCode();
                if (this.FixedCount != null)
                    hash = hash * 59 + this.FixedCount.GetHashCode();
                if (this.FixedLifeTimeUnit != null)
                    hash = hash * 59 + this.FixedLifeTimeUnit.GetHashCode();
                if (this.FixedLifeTimeLength != null)
                    hash = hash * 59 + this.FixedLifeTimeLength.GetHashCode();
                if (this.TrialIntervalUnit != null)
                    hash = hash * 59 + this.TrialIntervalUnit.GetHashCode();
                if (this.TrialIntervalLength != null)
                    hash = hash * 59 + this.TrialIntervalLength.GetHashCode();
                if (this.IntervalLength != null)
                    hash = hash * 59 + this.IntervalLength.GetHashCode();
                if (this.ScheduleType != null)
                    hash = hash * 59 + this.ScheduleType.GetHashCode();
                if (this.ScheduleFixedDay != null)
                    hash = hash * 59 + this.ScheduleFixedDay.GetHashCode();
                if (this.BaseMonth != null)
                    hash = hash * 59 + this.BaseMonth.GetHashCode();
                if (this.NoticePeriods != null)
                    hash = hash * 59 + this.NoticePeriods.GetHashCode();
                if (this.NoticePeriodsAfterCurrent != null)
                    hash = hash * 59 + this.NoticePeriodsAfterCurrent.GetHashCode();
                if (this.FixationPeriods != null)
                    hash = hash * 59 + this.FixationPeriods.GetHashCode();
                if (this.FixationPeriodsFull != null)
                    hash = hash * 59 + this.FixationPeriodsFull.GetHashCode();
                if (this.SupersedeMode != null)
                    hash = hash * 59 + this.SupersedeMode.GetHashCode();
                return hash;
            }
        }
    }

}
